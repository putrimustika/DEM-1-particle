# Single particle DEM program
# Created by Putri Widartiningsih
# v1.0 2025/7/17 Initial release
# v2.0 2025/7/18 Force calculations fixed
# v3.0 2025/8/22 .vtk output fixed

import math
import matplotlib.pyplot as plt
import os

# particle properties
radius                = 0.01
density               = 1000
spring                = 10000
restitution           = 0.9
sliding_friction_coef = 0.3
rolling_friction_coef = 0.2
gravity               = -9.81
output_frequency      = 100

# Initial conditions [x, y, z]
position = [[0.0, 0.01, 0.0]]
velocity = [[0.5, 0.0, 0.0]]
rotSpeed = [[0.0, 0.0, 0.0]]
rotAngle = [[0.0, 0.0, 0.0]]
displacement_t = [0.0, 0.0, 0.0]
particle = []

# ------------------------
mass    = 4/3 * math.pi * radius**3 * density
inertia = 2/5 * mass * radius**2
damping = -2 * math.log(restitution) * math.sqrt(mass*spring/(math.pi**2 + (math.log(restitution)**2)))

# simulation properties
dt = 0.00001
iteration = 30000
output_counter = 0

# Time step check
def time_step_check():
    suggested_dt = math.pi/10 * math.sqrt(mass/spring)
    if dt > suggested_dt:
        text = 'time step should be <= ' + str(suggested_dt) + ' s.'
        return(print(text))
    else:
        pass

# Gravitational forces
def gravitational():
    return mass * gravity

# Normal contact force
def normal_contact(displacement_n, relative_vel_n):
    if displacement_n <= 0:
        return -spring * displacement_n - damping * relative_vel_n
    elif abs(displacement_n) < 1e-6:  # small gap: still treat as contact
        return 0.0
    else:
        return 0.0

# Tangential contact force
def tangential_contact(F_normal, displacement_t, relative_vel_t):
    tangential_force = []
    for displacement_component, relative_velocity_component in zip(displacement_t,relative_vel_t):
        total_force_component = -spring * displacement_component - damping * relative_velocity_component
        tangential_force.append(total_force_component)
    tangential_magnitude = math.sqrt(sum(f**2 for f in tangential_force))
    max_friction = sliding_friction_coef * abs (F_normal)
    
    if tangential_magnitude <= max_friction:
        return tangential_force, False
    else:
        scale = max_friction / tangential_magnitude
        limited_force = [f * scale for f in tangential_force] 
        return limited_force, True

# Create output folder
def write_output(filename):
    try:
        os.mkdir(filename)
        print("Directory 'output' created succesfully")
    except FileExistsError:
        pass

# Write .vtk file
def write_vtk(filename, positions, trans_velocity, rot_velocity, radius):
    with open("output/"+filename, 'w') as f:
        f.write("# vtk DataFile Version 3.0\n")
        f.write("VTK output from DEM\n")
        f.write("ASCII\n")
        f.write("DATASET POLYDATA\n")
        
        f.write(f"POINTS {len(positions)} float\n")
        for pos in positions:
            f.write(f"{pos[0]} {pos[1]} {pos[2]}\n")

        f.write(f"\nPOINT_DATA {len(trans_velocity)}\n")
        f.write("VECTORS trans_velocity float\n")
        for t_vel in trans_velocity:
            f.write(f"{t_vel[0]} {t_vel[1]} {t_vel[2]}\n")

        f.write("\nVECTORS rot_velocity float\n")
        for r_vel in rot_velocity:
            f.write(f"{r_vel[0]} {r_vel[1]} {r_vel[2]}\n")
        
        f.write("SCALARS radius float 1\n")
        f.write("LOOKUP_TABLE default\n")
        f.write(f"{radius}\n")

# Run simulation
time_step_check()
write_output("output")

for t in range(iteration):
    # Current state
    pos_now = position[-1]
    vel_now = velocity[-1]
    rotSpeed_now = rotSpeed[-1]

    # Update position
    new_pos = [p + v * dt for p, v in zip(pos_now, vel_now)]
    position.append(new_pos)

    # Compute normal force, assume flat floor at y=0
    displacement_y = new_pos[1] - radius
    F_normal = normal_contact(displacement_y, vel_now[1])

    # Compute relative velocity at contact point
    r_vec = [0.0, -radius, 0.0]
    omega = rotSpeed_now
    omega_cross_r = [
        omega[1] * r_vec[2] - omega[2] * r_vec[1],  # x
        omega[2] * r_vec[0] - omega[0] * r_vec[2],  # y
        omega[0] * r_vec[1] - omega[1] * r_vec[0],]  # z
    rel_vel_t = [vel_now[i] + omega_cross_r[i] for i in range(3)]

    # Compute tengential displacement
    displacement_t = [d + v * dt for d, v in zip(displacement_t, rel_vel_t)]

    # Compute tangential force
    F_tangent, slipping = tangential_contact(F_normal, displacement_t, rel_vel_t)
    if slipping:
        displacement_t = [0.0, 0.0, 0.0]

    # Total force
    F_total = []
    F_gravity = gravitational()
    for i in range(3):
        if i == 1:
            F_total.append(F_tangent[i] + F_gravity)
        else:
            F_total.append(F_tangent[i])
    if F_normal != 0:
        F_total[1] += F_normal

    # Linear velocity update
    new_vel = [vel_now[i] + (F_total[i] / mass) * dt for i in range(3)]
    velocity.append(new_vel)

    # Compute rolling friction
    r_eff = radius
    if any(rotSpeed_now):
        mag = math.sqrt(sum(omega**2 for omega in rotSpeed_now))
        unit_vector = [omega / mag for omega in rotSpeed_now]
        Rolling_friction = [-rolling_friction_coef * F_normal * r_eff * d for d in unit_vector]
    else:
        Rolling_friction = [0.0, 0.0, 0.0]

    # Angular acceleration
    torque_contact = [-F_tangent[2] * radius, 0.0, F_tangent[0] * radius]
    torque = [torque_contact[i] + Rolling_friction[i] for i in range(3)]
    alpha = [torque[i] / inertia for i in range(3)]
    
    new_rotSpeed = [rotSpeed_now[i] + alpha[i] * dt for i in range(3)]
    rotSpeed.append(new_rotSpeed)

    new_rotAngle = [rotAngle[-1][i] + rotSpeed_now[i] * dt for i in range(3)]
    rotAngle.append(new_rotAngle)

    if t % output_frequency == 0:
        write_vtk(f"ptcl_{output_counter:04d}.vtk", [position[-1]], [velocity[-1]], [rotSpeed[-1]], radius)
        output_counter += 1


# Plot x-direction velocity and rolling speed (ω·R)
time = [i * dt for i in range(len(velocity))]
v_mag = [math.sqrt(v[0]**2 + v[1]**2 + v[2]**2) for v in velocity]
omega_mag = [math.sqrt(omega[0]**2 + omega[1]**2 + omega[2]**2)  for omega in rotSpeed]  # Assuming rolling around z-axis

with open("motion_data.txt", "w") as f:
    f.write("step,time,radius,x,y,z,rx,ry,rz\n")
    for i in range(len(position)):
        x, y, z = position[i]
        rx, ry, rz = rotAngle[i]
        f.write(f"{i},{i*dt},{radius},{x},{y},{z},{rx},{ry},{rz}\n")

fig, ax1 = plt.subplots(figsize=(10,5))

ax1.set_xlabel('Time(s)')
ax1.set_ylabel('Translational velocity magnitude (m/s)', color='blue')
line1, = ax1.plot(time, v_mag, color='blue')

ax2 = ax1.twinx()
ax2.set_ylabel('Rotational velocity magnitude (rad/s)', color='red')
line2, = ax2.plot(time, omega_mag, color='red')

fig.suptitle('3D Rolling Motion: Velocity vs Rolling Speed')
lines = [line1, line2]
labels = [l.get_label() for l in lines]
ax1.grid(True)
plt.show()
